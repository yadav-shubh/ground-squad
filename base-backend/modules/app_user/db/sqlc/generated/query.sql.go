// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package generated

import (
	"context"
	"database/sql"
)

const createAppUser = `-- name: CreateAppUser :one
INSERT INTO auth.app_users (
    first_name, last_name, mobile_no, preferred_user_name,
    email, role_id, is_active, is_deleted,
    fcm_token, created_at, updated_at,
    created_by, updated_by, last_active_date
) VALUES (
             $1, $2, $3, $4,
             $5, $6, $7, $8,
             $9,
             (extract(epoch from now()) * 1000)::bigint,
             (extract(epoch from now()) * 1000)::bigint,
             $10, $11, $12
         )
RETURNING id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
`

type CreateAppUserParams struct {
	FirstName         string
	LastName          sql.NullString
	MobileNo          string
	PreferredUserName string
	Email             string
	RoleID            int64
	IsActive          bool
	IsDeleted         bool
	FcmToken          sql.NullString
	CreatedBy         int64
	UpdatedBy         int64
	LastActiveDate    sql.NullInt64
}

func (q *Queries) CreateAppUser(ctx context.Context, arg CreateAppUserParams) (AuthAppUser, error) {
	row := q.db.QueryRowContext(ctx, createAppUser,
		arg.FirstName,
		arg.LastName,
		arg.MobileNo,
		arg.PreferredUserName,
		arg.Email,
		arg.RoleID,
		arg.IsActive,
		arg.IsDeleted,
		arg.FcmToken,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.LastActiveDate,
	)
	var i AuthAppUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.MobileNo,
		&i.PreferredUserName,
		&i.Email,
		&i.RoleID,
		&i.IsActive,
		&i.IsDeleted,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.LastActiveDate,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO auth.app_user_roles (
    role_name, description,
    created_at, updated_at,
    created_by, updated_by
) VALUES (
             $1, $2,
             (extract(epoch from now()) * 1000)::bigint,
             (extract(epoch from now()) * 1000)::bigint,
             $3, $4
         )
RETURNING id, role_name, description, created_at, updated_at, created_by, updated_by
`

type CreateRoleParams struct {
	RoleName    string
	Description string
	CreatedBy   int64
	UpdatedBy   int64
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (AuthAppUserRole, error) {
	row := q.db.QueryRowContext(ctx, createRole,
		arg.RoleName,
		arg.Description,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i AuthAppUserRole
	err := row.Scan(
		&i.ID,
		&i.RoleName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getAppUserByEmail = `-- name: GetAppUserByEmail :one
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetAppUserByEmail(ctx context.Context, email string) (AuthAppUser, error) {
	row := q.db.QueryRowContext(ctx, getAppUserByEmail, email)
	var i AuthAppUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.MobileNo,
		&i.PreferredUserName,
		&i.Email,
		&i.RoleID,
		&i.IsActive,
		&i.IsDeleted,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.LastActiveDate,
	)
	return i, err
}

const getAppUserByID = `-- name: GetAppUserByID :one
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetAppUserByID(ctx context.Context, id int64) (AuthAppUser, error) {
	row := q.db.QueryRowContext(ctx, getAppUserByID, id)
	var i AuthAppUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.MobileNo,
		&i.PreferredUserName,
		&i.Email,
		&i.RoleID,
		&i.IsActive,
		&i.IsDeleted,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.LastActiveDate,
	)
	return i, err
}

const getAppUserByMobile = `-- name: GetAppUserByMobile :one
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
WHERE mobile_no = $1
LIMIT 1
`

func (q *Queries) GetAppUserByMobile(ctx context.Context, mobileNo string) (AuthAppUser, error) {
	row := q.db.QueryRowContext(ctx, getAppUserByMobile, mobileNo)
	var i AuthAppUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.MobileNo,
		&i.PreferredUserName,
		&i.Email,
		&i.RoleID,
		&i.IsActive,
		&i.IsDeleted,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.LastActiveDate,
	)
	return i, err
}

const getAppUserByPreferredUserName = `-- name: GetAppUserByPreferredUserName :many
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
WHERE preferred_user_name = $1
ORDER BY id
`

func (q *Queries) GetAppUserByPreferredUserName(ctx context.Context, preferredUserName string) ([]AuthAppUser, error) {
	rows, err := q.db.QueryContext(ctx, getAppUserByPreferredUserName, preferredUserName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthAppUser
	for rows.Next() {
		var i AuthAppUser
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.MobileNo,
			&i.PreferredUserName,
			&i.Email,
			&i.RoleID,
			&i.IsActive,
			&i.IsDeleted,
			&i.FcmToken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.LastActiveDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, role_name, description, created_at, updated_at, created_by, updated_by
FROM auth.app_user_roles
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetRoleByID(ctx context.Context, id int64) (AuthAppUserRole, error) {
	row := q.db.QueryRowContext(ctx, getRoleByID, id)
	var i AuthAppUserRole
	err := row.Scan(
		&i.ID,
		&i.RoleName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, role_name, description, created_at, updated_at, created_by, updated_by
FROM auth.app_user_roles
WHERE role_name = $1
LIMIT 1
`

func (q *Queries) GetRoleByName(ctx context.Context, roleName string) (AuthAppUserRole, error) {
	row := q.db.QueryRowContext(ctx, getRoleByName, roleName)
	var i AuthAppUserRole
	err := row.Scan(
		&i.ID,
		&i.RoleName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const listActiveUsers = `-- name: ListActiveUsers :many
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
WHERE is_active = TRUE
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListActiveUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListActiveUsers(ctx context.Context, arg ListActiveUsersParams) ([]AuthAppUser, error) {
	rows, err := q.db.QueryContext(ctx, listActiveUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthAppUser
	for rows.Next() {
		var i AuthAppUser
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.MobileNo,
			&i.PreferredUserName,
			&i.Email,
			&i.RoleID,
			&i.IsActive,
			&i.IsDeleted,
			&i.FcmToken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.LastActiveDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppUsers = `-- name: ListAppUsers :many
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListAppUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAppUsers(ctx context.Context, arg ListAppUsersParams) ([]AuthAppUser, error) {
	rows, err := q.db.QueryContext(ctx, listAppUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthAppUser
	for rows.Next() {
		var i AuthAppUser
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.MobileNo,
			&i.PreferredUserName,
			&i.Email,
			&i.RoleID,
			&i.IsActive,
			&i.IsDeleted,
			&i.FcmToken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.LastActiveDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedUsers = `-- name: ListDeletedUsers :many
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
WHERE is_deleted = TRUE
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListDeletedUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListDeletedUsers(ctx context.Context, arg ListDeletedUsersParams) ([]AuthAppUser, error) {
	rows, err := q.db.QueryContext(ctx, listDeletedUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthAppUser
	for rows.Next() {
		var i AuthAppUser
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.MobileNo,
			&i.PreferredUserName,
			&i.Email,
			&i.RoleID,
			&i.IsActive,
			&i.IsDeleted,
			&i.FcmToken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.LastActiveDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, role_name, description, created_at, updated_at, created_by, updated_by
FROM auth.app_user_roles
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListRolesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListRoles(ctx context.Context, arg ListRolesParams) ([]AuthAppUserRole, error) {
	rows, err := q.db.QueryContext(ctx, listRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthAppUserRole
	for rows.Next() {
		var i AuthAppUserRole
		if err := rows.Scan(
			&i.ID,
			&i.RoleName,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByRole = `-- name: ListUsersByRole :many
SELECT id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
FROM auth.app_users
WHERE role_id = $1
ORDER BY id
LIMIT $2 OFFSET $3
`

type ListUsersByRoleParams struct {
	RoleID int64
	Limit  int32
	Offset int32
}

func (q *Queries) ListUsersByRole(ctx context.Context, arg ListUsersByRoleParams) ([]AuthAppUser, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByRole, arg.RoleID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthAppUser
	for rows.Next() {
		var i AuthAppUser
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.MobileNo,
			&i.PreferredUserName,
			&i.Email,
			&i.RoleID,
			&i.IsActive,
			&i.IsDeleted,
			&i.FcmToken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.LastActiveDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppUser = `-- name: UpdateAppUser :one
UPDATE auth.app_users
SET
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    mobile_no = COALESCE($4, mobile_no),
    preferred_user_name = COALESCE($5, preferred_user_name),
    email = COALESCE($6, email),
    role_id = COALESCE($7, role_id),
    is_active = COALESCE($8, is_active),
    is_deleted = COALESCE($9, is_deleted),
    fcm_token = COALESCE($10, fcm_token),
    updated_by = COALESCE($11, updated_by),
    last_active_date = COALESCE($12, last_active_date)
WHERE id = $1
RETURNING id, first_name, last_name, mobile_no, preferred_user_name, email, role_id, is_active, is_deleted, fcm_token, created_at, updated_at, created_by, updated_by, last_active_date
`

type UpdateAppUserParams struct {
	ID                int64
	FirstName         string
	LastName          sql.NullString
	MobileNo          string
	PreferredUserName string
	Email             string
	RoleID            int64
	IsActive          bool
	IsDeleted         bool
	FcmToken          sql.NullString
	UpdatedBy         int64
	LastActiveDate    sql.NullInt64
}

func (q *Queries) UpdateAppUser(ctx context.Context, arg UpdateAppUserParams) (AuthAppUser, error) {
	row := q.db.QueryRowContext(ctx, updateAppUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.MobileNo,
		arg.PreferredUserName,
		arg.Email,
		arg.RoleID,
		arg.IsActive,
		arg.IsDeleted,
		arg.FcmToken,
		arg.UpdatedBy,
		arg.LastActiveDate,
	)
	var i AuthAppUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.MobileNo,
		&i.PreferredUserName,
		&i.Email,
		&i.RoleID,
		&i.IsActive,
		&i.IsDeleted,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.LastActiveDate,
	)
	return i, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE auth.app_user_roles
SET
    role_name = COALESCE($2, role_name),
    description = COALESCE($3, description),
    updated_by = COALESCE($4, updated_by)
WHERE id = $1
RETURNING id, role_name, description, created_at, updated_at, created_by, updated_by
`

type UpdateRoleParams struct {
	ID          int64
	RoleName    string
	Description string
	UpdatedBy   int64
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (AuthAppUserRole, error) {
	row := q.db.QueryRowContext(ctx, updateRole,
		arg.ID,
		arg.RoleName,
		arg.Description,
		arg.UpdatedBy,
	)
	var i AuthAppUserRole
	err := row.Scan(
		&i.ID,
		&i.RoleName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
